{"version":3,"file":"static/js/97.6400d7d3.chunk.js","mappings":"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","sources":["experiment-tracking/components/runs-compare/charts/ParallelCoordinatesPlot.tsx"],"sourcesContent":["import React, { useCallback, useEffect, useRef, useState } from 'react';\nimport { Skeleton } from '@databricks/design-system';\nimport Parcoords from 'parcoord-es';\nimport 'parcoord-es/dist/parcoords.css';\nimport { scaleLinear } from 'd3-scale';\nimport { useDynamicPlotSize, truncateString } from './CompareRunsCharts.common';\nimport './ParallelCoordinatesPlot.css';\n\nconst COLOR_BAR_LOWER = '#3182bd';\nconst COLOR_BAR_UPPER = '#f33';\n\n/**\n * Attaches custom tooltip to the axis label inside SVG\n */\nconst attachCustomTooltip = (toolTipClass: string, labelText: string, targetLabel: Element) => {\n  const tooltipPadding = 4;\n  const svgNS = 'http://www.w3.org/2000/svg';\n  const tooltipGroup = document.createElementNS(svgNS, 'g');\n  const newRect = document.createElementNS(svgNS, 'rect');\n  const newText = document.createElementNS(svgNS, 'text');\n  newText.innerHTML = labelText;\n  newText.setAttribute('fill', 'black');\n  tooltipGroup.classList.add(toolTipClass);\n  tooltipGroup.appendChild(newRect);\n  tooltipGroup.appendChild(newText);\n  targetLabel.parentNode?.insertBefore(tooltipGroup, targetLabel.nextSibling);\n\n  const textBBox = newText.getBBox();\n\n  newRect.setAttribute('x', (textBBox.x - tooltipPadding).toString());\n  newRect.setAttribute('y', (textBBox.y - tooltipPadding).toString());\n  newRect.setAttribute('width', (textBBox.width + 2 * tooltipPadding).toString());\n  newRect.setAttribute('height', (textBBox.height + 2 * tooltipPadding).toString());\n  newRect.setAttribute('fill', 'white');\n};\n\nconst ParallelCoordinatesPlotImpl = (props: {\n  data: any;\n  metricKey: string;\n  selectedParams: string[];\n  selectedMetrics: string[];\n  onHover: (runUuid?: string) => void;\n  onUnhover: () => void;\n  closeContextMenu: () => void;\n  width: number;\n  height: number;\n  axesRotateThreshold: number;\n  selectedRunUuid: string | null;\n}) => {\n  // De-structure props here so they will be easily used\n  // as hook dependencies later on\n  const {\n    onHover,\n    onUnhover,\n    selectedRunUuid,\n    data,\n    axesRotateThreshold,\n    selectedMetrics,\n    selectedParams,\n    width: chartWidth,\n    height: chartHeight,\n    closeContextMenu,\n  } = props;\n  const chartRef = useRef<HTMLDivElement>(null);\n  const parcoord: any = useRef<null>();\n\n  // Keep the state of the actually hovered run internally\n  const [hoveredRunUuid, setHoveredRunUuid] = useState('');\n\n  // Basing on the stateful hovered run uuid, call tooltip-related callbacks\n  useEffect(() => {\n    if (hoveredRunUuid) {\n      onHover?.(hoveredRunUuid);\n    } else {\n      onUnhover?.();\n    }\n  }, [hoveredRunUuid, onHover, onUnhover]);\n\n  // Memoize this function so it won't cause dependency re-triggers\n  const getActiveData = useCallback(() => {\n    if (parcoord.current.brushed() !== false) return parcoord.current.brushed();\n    return parcoord.current.data();\n  }, []);\n\n  // Basing on the stateful hovered run uuid and selected run uuid, determine\n  // which runs should be highlighted\n  useEffect(() => {\n    if (!parcoord.current) {\n      return;\n    }\n    // Get immediate active data\n    const activeData = getActiveData();\n\n    // Get all (at most two) runs that are highlighted and/or selected\n    const runsToHighlight = activeData.filter((d: any) =>\n      [hoveredRunUuid, selectedRunUuid].includes(d.uuid),\n    );\n\n    // Either select them or unselect all\n    if (runsToHighlight.length) {\n      parcoord.current.highlight(runsToHighlight);\n    } else {\n      parcoord.current.unhighlight();\n    }\n  }, [hoveredRunUuid, selectedRunUuid, getActiveData]);\n\n  const getClickedLines = useCallback(\n    (mouseLocation: { offsetX: number; offsetY: number }) => {\n      const clicked: [number, number][] = [];\n      const activeData = getActiveData();\n      if (activeData.length === 0) return false;\n\n      const graphCentPts = getCentroids();\n      if (graphCentPts.length === 0) return false;\n\n      // find between which axes the point is\n      const potentialAxeNum: number | boolean = findAxes(mouseLocation, graphCentPts[0]);\n      if (!potentialAxeNum) return false;\n      const axeNum: number = potentialAxeNum;\n\n      graphCentPts.forEach((d: [number, number][], i: string | number) => {\n        if (isOnLine(d[axeNum - 1], d[axeNum], mouseLocation, 2)) {\n          clicked.push(activeData[i]);\n        }\n      });\n\n      return [clicked];\n    },\n    [getActiveData],\n  );\n\n  const highlightLineOnHover = useCallback(\n    (mouseLocation: { offsetX: number; offsetY: number }) => {\n      // compute axes locations\n      const axes_left_bounds: number[] = [];\n      let axes_width = 0;\n      const wrapperElement = chartRef.current;\n\n      if (!wrapperElement) {\n        return;\n      }\n\n      wrapperElement.querySelectorAll('.dimension').forEach(function getAxesBounds(element) {\n        const transformValue = element.getAttribute('transform');\n        // transformValue is a string like \"transform(100)\"\n        if (transformValue) {\n          const parsedTransformValue = parseFloat(transformValue.split('(')[1].split(')')[0]);\n          axes_left_bounds.push(parsedTransformValue);\n          const { width } = (element as SVGGraphicsElement).getBBox();\n          if (axes_width === 0) axes_width = width;\n        }\n      });\n\n      const axes_locations: any[] = [];\n      for (let i = 0; i < axes_left_bounds.length; i++) {\n        axes_locations.push(axes_left_bounds[i] + axes_width / 2);\n      }\n\n      let clicked = [];\n\n      const clickedData = getClickedLines(mouseLocation);\n\n      let foundRunUuid = '';\n      if (clickedData && clickedData[0].length !== 0) {\n        [clicked] = clickedData;\n\n        if (clicked.length > 1) {\n          clicked = [clicked[1]];\n        }\n\n        // check if the mouse is over an axis with tolerance of 10px\n        if (axes_locations.some((x) => Math.abs(x - mouseLocation.offsetX) < 10)) {\n          // We are hovering over axes, do nothing\n        } else {\n          const runData: any = clicked[0];\n          foundRunUuid = runData['uuid'];\n        }\n      }\n      setHoveredRunUuid(foundRunUuid);\n    },\n    [chartRef, getClickedLines],\n  );\n\n  const getCentroids = () => {\n    const margins = parcoord.current.margin();\n    const brushedData = parcoord.current.brushed().length\n      ? parcoord.current.brushed()\n      : parcoord.current.data();\n\n    return brushedData.map((d: any) => {\n      const centroidPoints = parcoord.current.compute_real_centroids(d);\n      return centroidPoints.map((p: any[]) => [p[0] + margins.left, p[1] + margins.top]);\n    });\n  };\n\n  const findAxes = (testPt: { offsetX: number; offsetY: number }, cenPts: string | any[]) => {\n    // finds between which two axis the mouse is\n    const x = testPt.offsetX;\n\n    // make sure it is inside the range of x\n    if (cenPts[0][0] > x) return false;\n    if (cenPts[cenPts.length - 1][0] < x) return false;\n\n    // find between which segment the point is\n    for (let i = 0; i < cenPts.length; i++) {\n      if (cenPts[i][0] > x) return i;\n    }\n    return false;\n  };\n\n  const isOnLine = (\n    startPt: [number, number],\n    endPt: [number, number],\n    testPt: { offsetX: number; offsetY: number },\n    tol: number,\n  ) => {\n    // check if test point is close enough to a line\n    // between startPt and endPt. close enough means smaller than tolerance\n    const x0 = testPt.offsetX;\n    const y0 = testPt.offsetY;\n    const [x1, y1] = startPt;\n    const [x2, y2] = endPt;\n    const Dx = x2 - x1;\n    const Dy = y2 - y1;\n    const delta =\n      Math.abs(Dy * x0 - Dx * y0 - x1 * y2 + x2 * y1) /\n      Math.sqrt(Math.pow(Dx, 2) + Math.pow(Dy, 2));\n    if (delta <= tol) return true;\n    return false;\n  };\n\n  useEffect(() => {\n    if (chartRef !== null) {\n      const num_axes = selectedParams.length + selectedMetrics.length;\n      const axesLabelTruncationThreshold = num_axes > axesRotateThreshold ? 15 : 15;\n      const tickLabelTruncationThreshold = num_axes > axesRotateThreshold ? 9 : 9;\n      const maxAxesLabelWidth = (chartWidth / num_axes) * 0.8;\n      const maxTickLabelWidth = (chartWidth / num_axes) * 0.4;\n\n      // last element of selectedMetrics is the primary metric\n      const metricKey: string = selectedMetrics[selectedMetrics.length - 1];\n      // iterate through runs in data to find max and min of metricKey\n      const metricVals = data.map((run: any) => run[metricKey]);\n      const minValue = Math.min(...metricVals.filter((v: number) => !isNaN(v)));\n      const maxValue = Math.max(...metricVals.filter((v: number) => !isNaN(v)));\n\n      // use d3 scale to map metric values to colors\n      const color_set = scaleLinear<string>()\n        .domain([minValue, maxValue])\n        .range([COLOR_BAR_LOWER, COLOR_BAR_UPPER]);\n\n      const wrapperElement = chartRef.current;\n\n      // clear the existing chart state\n      if (wrapperElement) {\n        wrapperElement.querySelector('#wrapper svg')?.remove();\n      }\n\n      // clear old canvases if they exist\n      if (wrapperElement) {\n        wrapperElement.querySelectorAll('canvas').forEach((canvas) => canvas.remove());\n      }\n      const getAxesTypes = () => {\n        const keys = Object.keys(data[0]);\n        const nonNullValues = keys.map((key) =>\n          data.map((d: any) => d[key]).filter((v: any) => v !== null),\n        );\n        const types = nonNullValues.map((v: any) => {\n          if (v.every((x: any) => !isNaN(x))) return 'number';\n          return 'string';\n        });\n        return Object.fromEntries(keys.map((_, i) => [keys[i], { type: types[i] }]));\n      };\n\n      parcoord.current = Parcoords()(chartRef.current)\n        .width(chartWidth)\n        .height(chartHeight)\n        .data(data)\n        .dimensions(getAxesTypes())\n        .alpha(0.8)\n        .alphaOnBrushed(0.2)\n        .hideAxis(['uuid'])\n        .lineWidth(1)\n        .color((d: any) => {\n          if (d && metricKey in d && d[metricKey] !== 'null') {\n            return color_set(d[metricKey]);\n          } else {\n            return '#f33';\n          }\n        })\n        .createAxes()\n        .render()\n        .reorderable()\n        .brushMode('1D-axes');\n\n      // add hover event\n\n      if (!wrapperElement) {\n        return;\n      }\n\n      // if brushing, clear selected lines\n      parcoord.current.on('brushend', () => {\n        parcoord.current.unhighlight();\n        closeContextMenu();\n      });\n\n      // Add event listeners just once\n      wrapperElement\n        .querySelector('#wrapper svg')\n        ?.addEventListener('mousemove', function mouseMoveHandler(ev: Event) {\n          const { offsetX, offsetY } = ev as MouseEvent;\n          highlightLineOnHover({ offsetX, offsetY });\n        });\n\n      wrapperElement.querySelector('#wrapper svg')?.addEventListener('mouseout', () => {\n        setHoveredRunUuid('');\n      });\n\n      // rotate and truncate axis labels\n      wrapperElement.querySelectorAll('.parcoords .label').forEach((e) => {\n        const originalLabel = e.innerHTML;\n        if (num_axes > axesRotateThreshold) {\n          e.setAttribute('transform', 'rotate(-30)');\n        }\n        e.setAttribute('y', '-20');\n        e.setAttribute('x', '20');\n        const width_pre_truncation = e.getBoundingClientRect().width;\n        if (width_pre_truncation > maxAxesLabelWidth) {\n          e.innerHTML = truncateString(originalLabel, axesLabelTruncationThreshold);\n          if (originalLabel !== e.innerHTML) {\n            attachCustomTooltip('axis-label-tooltip', originalLabel, e);\n          }\n        }\n      });\n\n      // truncate tick labels\n      wrapperElement.querySelectorAll('.parcoords .tick text').forEach((e) => {\n        const originalLabel = e.innerHTML;\n        const width_pre_truncation = e.getBoundingClientRect().width;\n        if (width_pre_truncation > maxTickLabelWidth) {\n          e.innerHTML = truncateString(originalLabel, tickLabelTruncationThreshold);\n          if (originalLabel !== e.innerHTML) {\n            attachCustomTooltip('tick-label-tooltip', originalLabel, e);\n          }\n        }\n      });\n\n      // draw color bar\n      const lg = parcoord.current.svg\n        .append('defs')\n        .append('linearGradient')\n        .attr('id', 'mygrad') // id of the gradient\n        .attr('x1', '0%')\n        .attr('x2', '0%')\n        .attr('y1', '0%')\n        .attr('y2', '100%'); // since its a vertical linear gradient\n      lg.append('stop')\n        .attr('offset', '0%')\n        .style('stop-color', '#f33') // end in red\n        .style('stop-opacity', 1);\n      lg.append('stop')\n        .attr('offset', '100%')\n        .style('stop-color', '#3182bd') // start in blue\n        .style('stop-opacity', 1);\n\n      // place the color bar right after the last axis\n      // D3's select() has a hard time inside shadow DOM, let's use querySelector instead\n      const parcoord_dimensions = chartRef.current?.querySelector('svg')?.getBoundingClientRect();\n      const last_axes = chartRef.current?.querySelector('.dimension:last-of-type');\n      if (!last_axes) return;\n      const last_axes_box = last_axes?.getBoundingClientRect();\n      const last_axes_location = last_axes?.getAttribute('transform');\n      // last_axes_location is a string like \"transform(100)\"\n      if (!last_axes_location) return;\n      const last_axes_location_value = parseFloat(last_axes_location.split('(')[1].split(')')[0]);\n      if (parcoord_dimensions) {\n        const rect = parcoord.current.svg.append('rect');\n        rect\n          .attr('x', last_axes_location_value + 20)\n          .attr('y', 0)\n          .attr('width', 20)\n          .attr('height', last_axes_box.height - 40)\n          .style('fill', 'url(#mygrad)');\n      }\n    }\n  }, [\n    // Don't retrigger this useEffect on the entire props object update, only\n    // on the fields that are actually relevant\n    data,\n    chartWidth,\n    chartHeight,\n    selectedParams,\n    selectedMetrics,\n    onHover,\n    axesRotateThreshold,\n    highlightLineOnHover,\n    chartRef,\n    closeContextMenu,\n  ]);\n\n  return (\n    <div\n      ref={chartRef}\n      id='wrapper'\n      style={{ width: props.width, height: props.height }}\n      className={'parcoords'}\n    />\n  );\n};\n\nexport const ParallelCoordinatesPlot = (props: any) => {\n  const wrapper = useRef<HTMLDivElement>(null);\n\n  const { layoutHeight, layoutWidth, setContainerDiv } = useDynamicPlotSize();\n\n  const [isResizing, setIsResizing] = useState(true);\n  const timeoutRef = useRef<ReturnType<typeof setTimeout>>();\n\n  useEffect(() => {\n    setContainerDiv(wrapper.current);\n  }, [setContainerDiv]);\n\n  useEffect(() => {\n    setIsResizing(true);\n    if (timeoutRef.current) {\n      clearTimeout(timeoutRef.current);\n    }\n    timeoutRef.current = setTimeout(() => {\n      setIsResizing(false);\n    }, 300); // Unblock after 300 ms\n  }, [layoutHeight, layoutWidth]);\n\n  return (\n    <div ref={wrapper} css={{ overflow: 'hidden', flex: '1', paddingTop: '20px', fontSize: 0 }}>\n      {isResizing ? (\n        <Skeleton />\n      ) : (\n        <ParallelCoordinatesPlotImpl {...props} width={layoutWidth} height={layoutHeight} />\n      )}\n    </div>\n  );\n};\n\nexport default ParallelCoordinatesPlot;\n"],"names":["attachCustomTooltip","toolTipClass","labelText","targetLabel","_targetLabel$parentNo","svgNS","tooltipGroup","document","createElementNS","newRect","newText","innerHTML","setAttribute","classList","add","appendChild","parentNode","insertBefore","nextSibling","textBBox","getBBox","x","toString","y","width","height","ParallelCoordinatesPlotImpl","props","onHover","onUnhover","selectedRunUuid","data","axesRotateThreshold","selectedMetrics","selectedParams","chartWidth","chartHeight","closeContextMenu","chartRef","useRef","parcoord","hoveredRunUuid","setHoveredRunUuid","useState","useEffect","getActiveData","useCallback","current","brushed","runsToHighlight","filter","d","includes","uuid","length","highlight","unhighlight","getClickedLines","mouseLocation","clicked","activeData","graphCentPts","getCentroids","potentialAxeNum","findAxes","axeNum","forEach","i","isOnLine","push","highlightLineOnHover","axes_left_bounds","axes_width","wrapperElement","querySelectorAll","element","transformValue","getAttribute","parsedTransformValue","parseFloat","split","axes_locations","clickedData","foundRunUuid","some","Math","abs","offsetX","margins","margin","map","compute_real_centroids","p","left","top","testPt","cenPts","startPt","endPt","tol","x0","y0","offsetY","x1","y1","x2","y2","Dx","Dy","sqrt","pow","_wrapperElement$query2","_wrapperElement$query3","_chartRef$current","_chartRef$current$que","_chartRef$current2","num_axes","axesLabelTruncationThreshold","tickLabelTruncationThreshold","maxAxesLabelWidth","maxTickLabelWidth","metricKey","metricVals","run","minValue","min","v","isNaN","maxValue","max","color_set","scaleLinear","domain","range","_wrapperElement$query","querySelector","remove","canvas","getAxesTypes","keys","Object","types","key","every","fromEntries","_","type","Parcoords","dimensions","alpha","alphaOnBrushed","hideAxis","lineWidth","color","createAxes","render","reorderable","brushMode","on","addEventListener","ev","e","originalLabel","getBoundingClientRect","truncateString","lg","svg","append","attr","style","parcoord_dimensions","last_axes","last_axes_box","last_axes_location","last_axes_location_value","_jsx","ref","id","className","_ref","name","styles","ParallelCoordinatesPlot","wrapper","layoutHeight","layoutWidth","setContainerDiv","useDynamicPlotSize","isResizing","setIsResizing","timeoutRef","clearTimeout","setTimeout","css","children","Skeleton"],"sourceRoot":""}